<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Glue </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Glue ">
    <meta name="generator" content="docfx 2.12.1.0">
    
    <link rel="shortcut icon" href="../images/NFX.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse nfx-navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a href="../index.html">
                <img id="nfx-logo" src="../images/NFX.Logo.Source.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="glue">Glue</h1>
              
<p><code>NFX.Glue</code> technology allows to develop distributed, service-oriented applications in a simple and efficient manner with minimal effort. 
Glue provides opportunity to link  (&quot;glue&quot;) different nodes in the distributed system (i.e. Agni nodes). 
It is, in some regard, an  analogue of Microsoft WCF but much easier to use.</p>
<p>The concept of Glue is very similar to what a concept of WCF is in terms of message passing, 
it is the message oriented framework where you exchange messages between contract-implementing/consuming end points.</p>
<p>For data exchange Glue uses CLR object teleportation via Slim Serializer that does not require to assign any auxiliary attributes to data 
(like data-member, data-contract and etc) - you can transfer any CLR object (as long as it does not have unmanaged state). </p>
<p>Glue is based on contracts - must be specified with GluedAttribute and has pluggable bindings that define protocol and serialization, 
it has security part that can be used in declarative or imperative form (permissions can be assigned to whole contract or separate methods directly). 
With changing <code>ServerInstanceMode</code> parameter of <code>LifeCycleAttribute</code> for contracts the Glue proposes opportunity to implement stateless or stateful server/client paradigm.</p>
<p><strong>Example 1:</strong></p>
<p>Service contract:</p>
<pre><code class="lang-csharp">[Glued]
[LifeCycle(ServerInstanceMode.Stateful, 20000)] // 20000-timeout to destruct in case of the loss of connection
[AuthenticationSupport]
public interface IJokeCalculator
{
  [Constructor]
  void Init(int value);

  [SultanPermission(250)] //some additional permission
  int Add(int value);

  int Sub(int value);

  [Destructor]
  int Done();
}
</code></pre><p>Service contract implementation:</p>
<pre><code class="lang-csharp">[NFX.Glue.ThreadSafe]
public class JokeCalculatorServer : IJokeCalculator
{
  private int m_Value; //state is retained between calls

  public void Init(int value)
  {
    m_Value = value;
  }

  public int Add(int value)
  {
    m_Value += value;
    return m_Value;
  }
}
</code></pre><p>Client:</p>
<pre><code class="lang-csharp">public class JokeCalculatorClient : ClientEndPoint, IJokeCalculator
{
  ...
  public int Add(int value)
  {
    // call to server and return result
  }
}
</code></pre><pre><code class="lang-csharp">var node = new Node(&quot;sync://192.168.1.23:8000&quot;);
using (var cl = new JokeCalculatorClient(node))
{
  cl.Init(234);
  cl.Add(3);
  Assert.AreEqual(237, cl.Done()); // deallocate instance
}
</code></pre><h2 id="binding">Binding</h2>
<p>The Glue has concept of binding just like WCF does. 
Binding tells you what kind of protocol and what kind of message exchange pattern is going to be used between the endpoints. 
The Glue has a family of bindings called native bindings because they are native to Glue and are implemented right in Glue project. There are two of them. 
First one is called MPX which stands for multiplexing binding that is bidirectional  socket. 
It sends information and it doesn’t block the socket channel until the result comes back for the two way calls. 
It multiplexes one socket for multiple calls. The another binding is called Sync binding which is similar to MPX only it is 100% blocking synchronous socket. 
The best performance you can get for a large transfers is through synchronous binding because synchronous model programming is more efficient than asynchronous 
one for a special kinds of operations. 
Both of these binding (MPX and Sync) use Slim Serializer that is highly optimized dynamically compiling expression tree based serializer, 
it allows to serialize complex graphs, including cyclical, acyclical, network like, self-referencing with transitive references graphs.
The Glue is configured from application container - &quot;glue&quot; section is used. In this section a lot of parameters can be tuned, 
e.g. message tracing, receive buffer window sizes, timeouts and etc., inspectors can be injected, but basically thing to do here is to setup bindings, give them names, define types that handle those binding.
Also servers are defined here in corresponding section. Node attribute defines what binding should be used and what address should be listen. 
There is specified what servers should be exposed on that address.</p>
<p><strong>Example 2:</strong></p>
<pre><code class="lang-js">glue
{
  bindings
  {
    binding
    {
      name=&quot;sync&quot;
      type=&quot;NFX.Glue.Native.SyncBinding&quot; 
    }
  }

  servers
  {
    server
    {
      name=&quot;sync&quot;
      node=&quot;sync://*:8000&quot;
      contract-servers=&quot;TestServer.Glue.JokeCalculatorServer, TestServer&quot;
    }
  }
}
</code></pre><p>It should be noted that Glue Client Compiler gluec.exe tool can be used in command line to automatically generate client classes for corresponding contracts.</p>
<h2 id="security">Security</h2>
<p>Let see on the example how interaction between nodes with some security requirements can be implemented with Glue technology.
Here is configuration on the server node. On the client node only bindings section is required.</p>
<pre><code class="lang-js">application
{  
  glue
  {   
    bindings
    {
      binding
      {
        name=&quot;sync&quot;
        type=&quot;NFX.Glue.Native.SyncBinding, NFX&quot;
        server-transport
        {
          rcv-buf-size=131072
          snd-buf-size=131072
          rcv-timeout=15000
          snd-timeout=15000
        }
      }
    }

    servers
    {
      server
      {
        node=&quot;sync://localhost:8080&quot;
        contract-servers=&quot;Glue.Server.Services.SecureService, Glue.Server&quot;
      }
    }
  }
</code></pre><p>In this example some security requirements are set. 
Here are two registered users with different permission levels (see <code>NFX.Security.AccessLevel</code> that sets level of access granted to user for certain permission).</p>
<pre><code class="lang-js">security
{
  users
  {
    user
    {
      name=&quot;Clinton&quot;
      description=&quot;Bill Clinton&quot;
      id=&quot;clinton&quot;
      password=&quot;89c246298be2b6113fb10ba80f3c6956&quot; // phash &#39;billy&#39;
      rights
      {
        specialized
        {
          superman  {level=1}
          president {level=1}
        }
        gov
        {
          executive {level=0}  // he is not current president
        }
      }
    }

    user
    {
      name=&quot;Trump&quot;
      description=&quot;Donald Trump&quot;
      id=&quot;trump&quot;
      password=&quot;10189466c646898c1fcf2363b5cf038d&quot; // phash &#39;chicago&#39;
      rights
      {
         specialized
         {
           superman  {level=1}
           president {level=1}
         }
       gov
         {
           executive {level=1} // he is current president
        }
      }
    }
  }
}
</code></pre><p>As it was mentioned above contract should be specified with Glued attribute. AuthenticationSupport attribute indicates that contract supports authentication using AuthenticationHeader. When header is passed then Glue server will use its data to set user context through Application.SecurityManager. If this attribute not set then Glue runtime will ignore AuthenticationHeader that marshalls user authentication information. AdHocPermission attribute represents a permission check instance which is a-typical and is based on string   arguments.</p>
<pre><code class="lang-csharp">[Glued]
[AuthenticationSupport]
[AdHocPermission(&quot;specialized&quot;, &quot;superman&quot;, AccessLevel.VIEW)]
public interface ISecureService
{
  string Echo(string message);

  // This method can only accessed by superman
  // who is also a president
  [AdHocPermission(&quot;specialized&quot;, &quot;president&quot;, AccessLevel.VIEW)]
  string PresidentEcho(string message);
}

// Service on the server
public class SecureService : ISecureService
{
  public string Echo(string message)
  {
    return &quot;Secure service echo: &quot; + message;
  }

  [AdHocPermission(&quot;gov&quot;, &quot;executive&quot;, AccessLevel.VIEW)]
  public string PresidentEcho(string message)
  {
    return &quot;President secure echo: &quot; + message;
  }
}
</code></pre><p>Implementation of client class is received with calling</p>
<p>gluec.exe <assembly> /o cl-suffix=&quot;AutoClient&quot;<p>
<p>where <assembly> - path to CLR assembly to scan for types marked with Glued attribute and cl-suffix - class suffix gets attached at the end of client class name.<p>
<pre><code class="lang-csharp">public class SecureServiceAutoClient : ClientEndPoint,
  @Glue.@Contracts.@Services.@ISecureService
{
  private static TypeSpec   s_ts_CONTRACT;
  private static MethodSpec @s_ms_Echo_0;
  private static MethodSpec @s_ms_PresidentEcho_1;

  static SecureServiceAutoClient()
  {
    var t = typeof(@Contracts.@Services.@ISecureService);
    s_ts_CONTRACT = new TypeSpec(t);
    @s_ms_Echo_0 = new MethodSpec(t.GetMethod(&quot;Echo&quot;,
                                    new Type[]{ typeof(@System.@String) })
                                  );
    @s_ms_PresidentEcho_1 = new MethodSpec(t.GetMethod(&quot;PresidentEcho&quot;,
                                             new Type[]{ typeof(@System.@String) })
                                           );
  }

  ...

  public @System.@String @Echo(@System.@String  @message)
  {
    var call = Async_Echo(@message);
    return call.GetValue&lt;@System.@String&gt;();
  }

  public CallSlot Async_Echo(@System.@String @message)
  {
    var request = new RequestAnyMsg(s_ts_CONTRACT,
                                    @s_ms_Echo_0,
                                    false,
                                    RemoteInstance,
                                    new object[]{@message});
    return DispatchCall(request);
  }

  // two similar methods for ISecureService.PresidentEcho
}
</code></pre><p><code>ClientEndPoint</code> class represents an ancestor for client classes that make calls to server endpoints. 
This and descendant classes are thread safe only for making non-constructing/destructing remote calls, 
unless <code>ReserveTransport</code> flag is set to true in which case no operation is thread safe. 
This class is not thread safe in general, however Glue allows for concurrent remote calls via the same endpoint 
instance if the following conditions are met:</p>
<ul>
<li>The endpoint instance has not reserved its transport (<code>ReserveTransport</code>=false)</li>
<li>Either remote contract is stateless or none of the concurrent calls are constructing/destructing remote instance </li>
</ul>
<p>The second condition ensures that stateful remote instance is consistent, otherwise operations may get executed out-of-order in the multithreaded scenario.
<code>TypeSpec</code> and <code>MethodSpec</code> represent type and method specifications for marshalling contract types between glued peers correspondingly.
<code>DispatchCall</code> is method of <code>ClientEndPoint</code> class, it dispatches a call into binding passing message through client inspectors on this endpoint.
<code>CallSlot</code> represents a class that is immediately returned after transport sends RequestMsg. This class provides <code>CallStatus</code> and <code>RequestID</code> properties where the later is used to match the incoming <code>ResponseMsg</code>. <code>CallSlots</code> are kinds of &quot;spirit-less&quot; mailboxes that keep state about the call, but do not possess any threads/call events. Working with <code>CallSlots</code> from calling code&#39;s existing thread of execution is the most efficient way of working with Glue (in high load cases), as it does not create extra object instances for asynchronous coordination and continuation.
<code>CallSlot.GetValue</code> method returns a value from the other side, it gets the response message and checks it for errors, throwing <code>RemoteError</code> exception if one came from server. 
Accessing this property blocks calling thread until either <code>ResponseMsg</code> arrives or timeout expires. Accessing this method for one-way methods throws exception.
<code>RequestMsg</code> represents request message from client to server that contains contract type, method specification and invocation arguments which are included as object array. Although the most convenient and simple, this way of working with glue is slower than using its typed version which needs to be derived-from for every method (that allows to avoid boxing).
So fragment of code with <code>SecureServiceAutoClient</code> usage may look like:</p>
<pre><code class="lang-csharp">try
{
  using (var client =
               new SecureServiceAutoClient(&quot;sync://localhost:8080&quot;))
  {
    client.Headers.Add(new AuthenticationHeader(
                         new IDPasswordCredentials(user, password)));

    if (!isPresident)
      response = client.Echo(&quot;test&quot;);
    else
      response = client.PresidentEcho(&quot;test&quot;);

    System.Console.WriteLine(response);
  }
}
catch (Exception error)
{
  System.Console.WriteLine(error.Message());
}
</code></pre><p>Now due to security settings in the configuration and the contract there will be errors if you tries to log in neither as &quot;clinton&quot; or &quot;trump&quot;, 
or tries to send message to server as &quot;clinton&quot; with isPresident=true. 
If you log in as &quot;clinton&quot; you can use isPresident=false only and will get &quot;Secure service echo: test&quot; as a result. As &quot;trump&quot; you can use both values of isPresident and will get both corresponding responses.
In this fragment <code>AuthenticationHeader</code> marshalls user authentication information.</p>
</assembly></assembly>
            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2006-2017 ITAdapter Corp Inc<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
