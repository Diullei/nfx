<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Wave </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Wave ">
    <meta name="generator" content="docfx 2.12.1.0">
    
    <link rel="shortcut icon" href="../images/NFX.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse nfx-navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a href="../index.html">
                <img id="nfx-logo" src="../images/NFX.Logo.Source.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="wave">Wave</h1>
              
<h2 id="server-side">Server Side</h2>
<p>WAVE is a &quot;Web App View Enhanced&quot; web server which provides DYNAMIC web site services. 
This server is not meant to be exposed directly to the public Internet, rather it should be used as an application server behind the reverse proxy, such as NGINX. 
This server is designed to serve dynamic data-driven requests/APIs and not meant to be used for serving static content files (although it can).</p>
<p>Every request goes through a pipeline where the server checks if the incoming request is allowed, 
performs additional processing like logging or adding session state and finally serves the request. The pipeline consists of the following parts:</p>
<ul>
<li>Dispatcher - organize a process of request&#39;s passing through pipeline.</li>
<li>Gate - a logical filter of incoming requests, it is somewhat similar to a firewall - it allows/denies the traffic based on the set of rules.</li>
<li>Filters - performs actions like logging or handling session state. Unlike handlers, filters do not necessarily handle work rather augment the work context.</li>
<li>Handlers - where all actual work is done, they are final work execution destination.</li>
<li>The gate and filters are optional but the server must have at least one handler which may have its own set of filters specific to the request. The server matches handlers against a request based on URI. However, this may be overridden.</li>
</ul>
<p>In the next figure some request comes to the WAVE server. 
Dispatcher D passes it through gate G and filters F1, F2 and finds a handler H1 which matches the request. 
The handler applies its own filters F3, F4 and performs the actual work W1. If a handler has no filters it immediately executes the work.</p>
<p><img src="../../images/WAVE.pipeline.png" alt="pipeline" title="NFX WAVE Piepeline"></p>
<p>Typical WAVE server configuration that corresponds the figure above will look like as (the node prefix is required):</p>
<pre><code class="lang-js">nfx 
{
  wave
  {
    server
    {
      prefix { name=&quot;http://+:8080&quot; }
      dispatcher
      {
        gate    { name=&quot;G&quot; ... }
        filter  { name=&quot;F1&quot; order=1 type=&quot;F1&quot; }
        filter  { name=&quot;F2&quot; order=2 type=&quot;F2&quot; }

        handler
        {
          name=&quot;H1&quot; order=0 type=&quot;H1&quot;
          filter { name=&quot;F3&quot; order=0 type=&quot;F3&quot; }
          filter { name=&quot;F4&quot; order=1 type=&quot;F4&quot; }
        }
        handler { name=&quot;H2&quot; order=0 type=&quot;H2&quot; ... }
        handler { name=&quot;H3&quot; order=0 type=&quot;H3&quot; ... }
      }
    }
  }
}
</code></pre><p><strong>Example 1:</strong></p>
<pre><code class="lang-csharp">class TestHandler : WorkHandler
{
  public TestHandler(WorkDispatcher dispatcher, string name, int order, WorkMatch match)
    : base(dispatcher, name, order, match) {}

  public TestHandler(WorkDispatcher dispatcher, IConfigSectionNode confNode)
    : base(dispatcher, confNode) {}

  protected override void DoHandleWork(WorkContext work)
  {
    work.Response.WriteLine(&quot;Hello, world!&quot;);
  }
}

class Program
{
  static void Main(string[] args)
  {
    try
    {
      using (new ServiceBaseApplication(args, null))
      using (var ws = new WaveServer())
      {
        ws.Configure(null);
        ws.Start();
        Console.WriteLine(&quot;Web server started. Press &lt;ENTER&gt; to terminate...&quot;);
        Console.ReadLine();
      }
    }
    catch (Exception ex)
    {
      Console.WriteLine(ex.ToMessageWithType());
      System.Environment.ExitCode = -1;
    }
  }
}
</code></pre><p>with configuration:</p>
<pre><code class="lang-js">nfx
{
  wave
  {
    server
    {
      prefix { name=&quot;http://+:8080/&quot; }      
      dispatcher
      {
        handler
        {
          name=&quot;Test&quot;
          order=0
          type=&quot;WaveTest.TestHandler, WaveTest&quot;
          match {} 
        }
      }
    }
  }
}
</code></pre><p>Now the server will respond with &quot;Hello, world!&quot; to every request from <code>localhost:8080</code>.</p>
<p>WAVE implementation is based on a lightweight HttpListener that processes incoming HTTP requests via an injectable WorkDispatcher which governs the threading and WorkContext life cycle. 
The server processing pipeline is purposely designed to be synchronous-blocking (thread per call) which does not mean that the server is inefficient, to the contrary - this server design is specifically targeting short-called methods relying on a classical thread call stack. 
This approach obviates the need to create surrogate message loops/synchro contexts, tasks and other objects that introduce extra GC load. The server easily support &quot;dangling&quot; (left open indefinitely) WorkContext instances that can stream events (i.e. SSE/Server Push) and WebSockets from specially-purposed asynchronous notification threads.</p>
<p><code>WorkContext</code> represents a context for request/response server processing in WAVE framework and includes:</p>
<ul>
<li><code>WaveServer</code> - the server this context is under.</li>
<li><code>Request</code> - returns HttpListenerRequest object for this context.</li>
<li><code>Response</code> - a wrapper for HttpListenerResponse which represents Response object used to generate web responses to client.</li>
<li><code>WaveSession</code> - session that this context is linked with. It stores user geographical/location information. Also session contains CSRFToken - unique token assigned at session start used for checking of form posts (purpose - to provide Cross Site Request Forgery protection) and every MVC controllers of such kind must have SessionCSRFCheck attribute to pass corresponding check.</li>
<li><code>SessionFilter</code> - returns the first session filter which was injected in the processing line. It is the filter that manages the session state for this context.</li>
<li><code>WorkHandler</code> - a work handler instance that was matched to perform work on this context or null if the match has not been made yet.</li>
<li><code>GeoEntity</code> - geo location information as detected by GeoLookupHandler. If Session context is injected then get/set passes through into session object.</li>
<li><code>Items</code> - provides a thread-safe dictionary of items. The underlying collection is lazily allocated.</li>
<li><code>LastError</code> - if any error occurs during processing the request it will be stored in this property.</li>
<li><code>RequestedJSON</code> - returns true if client indicated in response that &quot;application/json&quot; is accepted.</li>
<li><code>Request method</code> indicators: IsPOST/IsGET/IsPUT/IsDELETE/IsPATCH.</li>
<li><code>Portal</code> - returns portal object for this request or null if no portal was injected. To make your web portal with NFX.WAVE library you can use Portal abstract class as a base. It represents a web portal that controls the mapping of types and themes within the site. Portals allow to host differently-looking/behaving sites in the same web application. And you can use Portal hub - a registry of portals. It establishes a context for portal inter-operation (i.e. so one portal may locate another by name) when some settings need to be cloned. This is an application-started singleton instance class. Theme concept is closely related with Portal. It groups various resources (such as css, scripts etc..) within a portal.</li>
<li><code>Match</code> - returns the WorkMatch instance that was made for this requested work or null if nothing was matched yet. WorkMatch decides whether the specifies WorkContext matches the requirements specified in the instance. The match may consider Request and Items properties of work context for match determination. Work matches do not belong to particular handler or filter, so they are stateless and their instances can be used by multiple different processors (i.e. handlers and filters).</li>
<li><code>Handled</code> - returns true when the work has been executed by the WorkHandler instance.</li>
<li><code>Aborted</code> - indicates whether the work context is logically finished and its nested processing (i.e. through Filters/Handlers) should stop. For example, when some filter detects a special condition (judging by the request) and generates the response and needs to abort the work request so it doesn&#39;t get filtered/processed anymore, it can set this property to true. This mechanism performs much better than throwing exceptions.</li>
<li><code>ReleaseWorkSemaphore</code> - releases work semaphore that throttles the processing of WorkContext instances. The WorkContext is released automatically in destructor, however there are cases when the semaphore release may be needed sooner, i.e. in a HTTP streaming application where work context instances are kept open indefinitely it may not be desirable to consider long-living work context instances as a throttling factor. Returns true if semaphore was released, false if it was not released during this call as it was already released before.</li>
<li><code>Log</code> - facilitates context-aware logging.</li>
<li><code>NeedsSession</code> - ensures that session is injected if session filter is present in processing chain. If session is already available then does nothing, otherwise fills Session property with either NEW session if user supplied no session token, OR gets session from session store as defined by the first SessionFilter in the chain.</li>
</ul>
<p>WAVE contains <code>WorkDispatcher</code> that represents a default dispatcher that dispatches <code>WorkContext</code> calls on the same thread that calls Dispatch(work). 
May extend this class to implement custom dispatchers, i.e. the once that maintain their own work queue/worker threads.</p>
<p>Implemented Handler types:</p>
<ul>
<li><code>CompositeHandler</code> - dispatches work to sub-handlers just like the dispatcher does.</li>
<li><code>ContextDumpHandler</code> - dumps WorkContext status - used for debugging purposes.</li>
<li><code>EmbeddedSiteHandler</code> - implements handler that serves content from assembly-embedded resources and class actions.</li>
<li><code>FileDownloadHandler</code> - downloads local files.</li>
<li><code>MVCHandler</code> - handles MVC-related requests.</li>
<li><code>NOPHandler</code> - implements handler that does nothing.</li>
<li><code>StockContentSiteHandler</code> - serves the embedded content of NFX.Wave library.</li>
<li><code>TemplateHandler</code> - implements handler that serves WaveTemplates.</li>
<li><code>TypeLookupHandler</code> - represents a base handler for all handlers that dynamically resolve type that performs actual work.</li>
<li><code>WorkHandler</code> - abstract, represents a base for all work handlers.</li>
</ul>
<p>Implemented  Filter types:</p>
<ul>
<li><code>BeforeAfterFilterBase</code> - abstract, provides base for filters that have before/after semantics.</li>
<li><code>ErrorFilter</code> - intercepts error that arise during processing and displays an error page for exceptions and error codes.</li>
<li><code>GeoLookupFilter</code> - upon match, looks up user&#39;s geolocation based on a IP address.</li>
<li><code>LoggingFilter</code> - logs information extracted from WorkContext.</li>
<li><code>PortalFilter</code> - manages injection of portal into the work context.</li>
<li><code>RedirectFilter</code> - upon match, redirects client to the specified URL resource.</li>
<li><code>SecurityFilter</code> - checks permissions before doing work.</li>
<li><code>SessionFilter</code> - manages session state in work context.</li>
<li><code>StopFilter</code> - stops the processing of WorkContext by throwing exception upon match.</li>
<li><code>WorkFilter</code> - abstract, represents a base for all work filters.</li>
</ul>
<p>Both <code>WorkDispatcher</code> and <code>WorkHandler</code> may have filters. In case of WorkDispatcher they would process every request, whereas located in <code>WorkHandler</code> they would filter specific cases.
<code>SessionFilter</code> manages session state in work context using ObjectStoreService as a back-end store by default. 
<code>ObjectStoreService</code> stores objects in process&#39;s memory, asynchronously saving them to an external non-volatile storage upon change and synchronously saving objects upon service stop using file-based FileObjectStoreProvider. 
Applications can use their own providers in order to save session in a different store. 
Another option is to override <code>SessionFilter.StowSession</code>. 
Applications should call <code>WorkContext.NeedsSession</code> method to ensure the session is created. 
By default NFX.WAVE stores session ID in WV.CV cookie. <code>FileObjectStoreProvider</code> uses root-path and GUID specified in the configuration file as the store directory.</p>
<p>In addition server side WAVE contains following classes:</p>
<ul>
<li><code>RecordModelGenerator</code> facilitates tasks of JSON generation for record models/rows as needed by WAVE.RecordModel client library. This class does not generate nested models, only flat models for particular row (i.e. id row has a complex type field, it will be serialized as &quot;object&quot;).</li>
<li><code>Record</code> represents a client-side &quot;Form&quot; - an analogue of <code>WAVE.RecordModel.Record</code> on server-side. The class is initialized from schema obtained from the server via JSON which is generated by <code>RecordModelGenerator</code>. 
<code>Record</code> class is usually used for API consumers that need to have the JS/client-like functionality on the server.</li>
</ul>
<h2 id="mvc">MVC</h2>
<p>The processing of MVC-related requests with using of WAVE framework passes in following stages:
According to adjusted configuration server matches appropriate MVC-handler. Typical configuration of MVC handler looks like:</p>
<pre><code class="lang-js">handler
{
  order=2
  type=&quot;NFX.Wave.Handlers.MVCHandler, NFX.Wave&quot;
  type-location
  {
    assembly=&quot;Example.exe&quot;
    ns { name=&quot;Example.Controllers&quot; }
  }
  match
  {
    path=&quot;/{type=mycontroller}/{mvc-action=myaction}&quot;
    var { query-name=&quot;*&quot; }
  }
}
</code></pre><p>MVC-handler has information about location of corresponding controller and tries to find appropriate MVC-action under this controller by comparing action 
attributes <code>NFX.Wave.MVC.ActionAttribute</code> that are assigned to methods in custom controller class that must be inherited from <code>NFX.Wave.MVC.Controller</code>. 
The controller that matches aforementioned handler may look like:</p>
<pre><code class="lang-csharp">public class MyController: Controller
{
  [Action(name : &quot;myaction&quot;, order : 2, matchScript : &quot;match{methods=GET}&quot;)]
  public object GetPerson (JSONDataMap req)
  {
    var row = new Person
    {
      ID = req[&quot;PersonID&quot;],
      FirstName = &quot;Yuriy&quot;,
      LastName = &quot;Gagarin&quot;
    };
    return new ClientRecord(row, null);
  }
}
</code></pre><p>To customize the Action attribute following parameters can be used:</p>
<ul>
<li><code>Name</code> - when set, specifies the invocation name override, null by default which means that the name of decorated member should be used.</li>
<li><code>Order</code> - dictates the matchmaking order of actions within the group.</li>
<li><code>MatchScript</code> - specify match script in Laconic config format.</li>
<li><code>StrictParamBinding</code> - must be set as true if default parameter binder should not perform indirect value conversions, i.e. integer tick number as date time.</li>
</ul>
<p>In addition controller classes and actions can be specified with following attributes:</p>
<ul>
<li><code>NoCacheAttribute</code> - decorates controller classes or actions that set NoCache headers in response.</li>
<li><code>SessionCSRFCheckAttribute</code> - decorates controller classes or actions that need to check CSRF token on POST against the user session.</li>
</ul>
<p>Handler invokes MVC-action (if matched) and include action result in response to client. 
There are several predefined MVC action result types that implement <code>IActionResult</code> interface, they decorate entities that get returned by MVC actions and can get executed to generate some result action (command pattern):</p>
<ul>
<li><code>FileDownload</code> - downloads a local file.</li>
<li><code>Redirect</code> - redirects user to some URL.</li>
<li><code>Picture</code> - returns/downloads an image.</li>
<li><code>ClientRecord</code> - returns row as JSON object for WAVE.RecordModel.Record constructor on client side.</li>
<li><code>JSONResult</code> - returns JSON object with JSON writing options. If JSON options are not needed then just return CLR object directly from controller action without this wrapper</li>
<li><code>Http404NotFound</code> - returns HTTP 404 - not found, it can be used in place of returning exceptions where needed as it is faster</li>
<li><code>Http403Forbidden</code> - returns HTTP 403 - forbidden, it can be used in place of returning exceptions where needed as it is faster.</li>
</ul>
<p>Besides in most cases action result is web page which is generated as instance of the class inherited from <code>NFX.Wave.Templatization.WaveTemplate</code>.</p>
<h2 id="client-side">Client Side</h2>
<p>On the client side WAVE framework is represented by javascript libraries <strong>wv.js</strong> and <strong>wv.gui.js</strong>. 
These libraries provide powerful instruments to implement complex reactive web applications. 
The framework contains:</p>
<ul>
<li>Various auxiliary General-Purpose Functions to work with strings, arrays and objects, different type conversion functions.</li>
<li>Geometry contains a large number of functions to work with geometry tasks.</li>
<li>Classes to build/render GUI elements like dialogs, toasts, forms, etc.</li>
<li><code>EventManager</code> mixin that implements the event-handler mechanism and can be added to any class.</li>
<li><code>RecordModel</code> contains classes for MVVM pattern implementation.</li>
<li><code>UTest</code> - implementation of unit testing concept.</li>
</ul>
<p>Walkable mixin that enables function chaining that facilitates lazy evaluation via lambda-functions, contains full set of projection, filtering, partitioning, aggregation, grouping and etc. operations - analogues of corresponding methods of <code>IEnumerable</code> in C#.</p>
<p>It is needed to pay more attention to <code>RecordModel</code>. It consists of:</p>
<ul>
<li><code>Record</code>. The purpose of this class is to represent server-side <code>NFX.DataAccess.CRUD.Schema</code> on the client side along with view model/controller. 
<code>Record</code> instances are initialized using server <code>NFX.Wave.Client.RecordModelGenerator</code> class that turns Schema into JSON object suitable for record initialization on client.</li>
<li><code>Field. Record</code> consists of fields and Field represents a <code>FieldDef</code> from server-side <code>NFX.DataAccess.CRUD.Schema</code> on the client side along with view model/controller.</li>
<li><code>RecordView</code> and <code>FieldView</code>. Binds Record model (an instance of <code>Record</code> class) with UI builder/rendering library (<strong>wv.gui.js</strong>) which dynamically builds the DOM in the attached view components. 
Thus, changes made to view model/data model in record instance will get automatically represented in the attached UI (dual way binding).</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code class="lang-js">var rec = new WAVE.RecordModel.Record({ID: &#39;REC-1&#39;, 
          fields:
          [
            {def: {Name: &#39;FirstName&#39;, Type: &#39;string&#39;}, val: &#39;John&#39;},
            {def: {Name: &#39;LastName&#39;, Type: &#39;string&#39;}, val: &#39;Smith&#39;},
            {def: {Name: &#39;Age&#39;, Type: &#39;int&#39;}, val: 33},
            {def: {Name: &#39;Helper&#39;, Type: &#39;string&#39;, Stored: false}}
          ]});

var d = JSON.stringify(rec.data());
</code></pre><p><strong>Example 2:</strong></p>
<pre><code class="lang-js">var rec = new WAVE.RecordModel.Record(&#39;ID-123456&#39;,
            function(){
              new this.Field({Name: &#39;FirstName&#39;,
                              Type: &#39;string&#39;,
                              Required: true});
              new this.Field({Name: &#39;LastName&#39;, Type: &#39;string&#39;});
              new this.Field({Name: &#39;Age&#39;, Type: &#39;int&#39;});
            }
          );
</code></pre><p><strong>Example 3:</strong></p>
<pre><code class="lang-js">var REC = new WAVE.RecordModel.Record({ID: &#39;R1&#39;,
            fields:
            [
              { def: { Name: &#39;FirstName&#39;, 
                       Type: &#39;string&#39;,
                       Required: true, 
                       DefaultValue: &#39;Bob&#39;,
                       Placeholder: &#39;Your First Name&#39; },
                val: &#39;John&#39;},
              { def: { Name: &#39;LastName&#39;, 
                       Type: &#39;string&#39;,
                       Required: false,
                       Placeholder: &#39;Your Last Name&#39;},
                val: &#39;Smith&#39;},
              { def: { Name: &#39;MusicType&#39;, 
                       Type: &#39;string&#39;,
                       Case: WAVE.RecordModel.CASE_UPPER,
                       LookupDict: {
                         RСK: &#39;Rock&#39;,
                         RAP: &#39;Rap&#39;,
                         CLS: &#39;Classical music&#39;}
                     }
              }
            ]}
          );

var RVIEW = new WAVE.RecordModel.RecordView(&#39;V1&#39;, REC);
</code></pre><p>HTML client-side code:</p>
<pre><code class="lang-html">&lt;form data-wv-rid=&quot;V1&quot;&gt;
  &lt;div class=&quot;fView&quot; data-wv-fname=&quot;FirstName&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;fView&quot; data-wv-fname=&quot;LastName&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;fView&quot; data-wv-fname=&quot;MusicType&quot;&gt;&lt;/div&gt;

  Record-level errors:
  &lt;div class=&quot;fView&quot; data-wv-fname=&quot;#&quot;&gt;&lt;/div&gt;
&lt;/form&gt;
</code></pre>
            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2006-2017 ITAdapter Corp Inc<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
